# Real-time ADS-B Tracking and Collision Warning System

## Introduction
With the increasing amount of air traffic, alongside the recent instances of aircraft collision and air traffic control outages, we hope to build a reliable collision warning system that is capable of tracking aircraft in real time. The Real-time ADS-B Tracking and Collision Warning System is an open-source application that monitors real-time air traffic using Automatic Dependent Surveillance–Broadcast (ADSB) data and provides early collision warning. It has a web-based 3D visualization UI with a backend that predicts and issues potential mid-air conflicts.

**Background**: Traditional collision avoidance in aviation is handled by onboard systems like TCAS (Traffic Collision Avoidance System), but those are proprietary and onboard-only. On the other hand, ADS-B has become a cornerstone technology in modern air traffic surveillance. Aircraft equipped with it periodically broadcast their GPS-derived position, altitude, velocity, and identification. This stream of real-time data enables us to track aircraft without traditional radar. This project aims to create an open-source, ground-based solution that not only tracks aircraft but also warns of impending conflicts and detects anomalous data, all using commodity hardware. The system will be accurate and responsive, addressing security concerns (like GPS spoofing or faulty transmitters), and present the information in an intuitive 3D interface.

**Use Cases**: This system can be used as a real-time air traffic monitor at small airfields or by hobbyists at home, alerting users to nearby traffic conflicts (for example, a drone operator could be warned of a manned aircraft approaching). Researchers might use the platform to experiment with new collision prediction algorithms or evaluate the frequency of conflict alerts in busy airspace. Overall, the system’s flexibility and open design make it suitable for educational demonstrations, airport traffic management supplements, or as a component in larger solutions for drones.

## System Architecture & Key Features

### 3D Visualization
We use CesiumJS to render all aircraft in an interactive 3D environment. The scene is initialized with a satellite imagery base layer (via Cesium Ion) and configured for our use case. Users can pan, zoom, and rotate the view to see aircraft from any angle, including a global view or a pilot’s perspective. Under the hood, each aircraft is rendered as a Cesium entity with a 3D model and a label, representing its current heading and pitch. The system includes a library of models (for example, a generic airliner, a small plane, a helicopter, etc.), and it selects an appropriate model based on the aircraft’s category. 

When a new aircraft is added to the scene, a Cesium entity is created with the model URI and a scaling factor suited to that type (e.g., large jet models are scaled down so that their visual size matches real dimensions relative to the globe). Alongside the model, a label is attached displaying the flight identifier (callsign or number). Additionally, a velocity cone is added to visualize an aircraft’s potential future flight path during the chosen time horizon based on its orientation and speed. On the side, it includes a side panel listing potential conflicts and forms for adjusting system parameters (e.g., the alert thresholds). Clicking the aircraft on the interface allows it to focus the camera on it. For example, clicking an aircraft in the conflict list or on the globe will smoothly transition the camera to follow that aircraft, helping the user investigate a situation in detail.

### Collision Detection (CPA-based Risk Analysis & Gaussian Probability Score)
The collision detection is implemented in the function detectCollisions(), which is invoked at the end of each update loop cycle. The code is structured to first reduce the search space through spatial partitioning. It defines a cell size (default ~20 NM) and uses a hashing function to assign each aircraft to a cell bucket. By not pairing aircraft from distant cells, we skip obvious non-conflicts early. The detection logic then iterates over these candidate pairs. For each pair, it first checks vertical separation: if the difference in altitude (barometric altitude) exceeds a set threshold (e.g., 1000 ft by default), the pair is skipped – the rationale being that large altitude differences mean one is likely safely above/below the other. 

Next, it computes the CPA, which carefully uses coordinates in Earth-Centered Earth-Fixed (ECEF) for accuracy. It calculates the closest point and time of the aircraft pair in the future, as well as their relative motion – if they are diverging, the pair is skipped. If not diverging, we now have a predicted CPA time t (seconds in the future) and distance d (in meters). It then goes through a 2D Gaussian risk model: it computes a threat score between 0 and 1 as 

$$
e^{-\bigl[\bigl(\tfrac{d}{\sigma_{d}}\bigr)^{2} + \bigl(\tfrac{t}{\sigma_{t}}\bigr)^{2}\bigr]}
$$

, where $σ_d$, $σ_t$ are parameters representing how sensitive the risk function is to distance and time. The effect is that a very small miss distance and short time will yield a score near 1 (high risk), whereas a distant or far-future crossing yields a score near 0 (negligible risk). If the value is above a predetermined threshold, then it will be marked as a potential conflict.

It then proceeds to visualize the results: it adds a red/orange/yellow line entity connecting the two aircraft positions and a text label showing the risk percentage. Simultaneously, the summary panel is refreshed with the new sets of conflicts and their details. One important implementation detail is the handling of configurable parameters. Rather than hard-coding values, the system uses a param object that is initially read from UI input fields and is updated on-the-fly when the user changes a setting. For example, a user can increase the lookahead horizon from 60 seconds to 120 seconds, or tighten the vertical separation threshold, and these new values will be used immediately by the next iteration. This flexibility in the implementation enables quick tuning and what-if experimentation, which was useful during development to find a reasonable balance for alert sensitivity. It also makes the system adaptable to different scenarios; e.g., for drone traffic, one might use a shorter horizon and smaller cell size, whereas for fast jets, one might use larger values.

Ultimately, this feature provides an automatic “safety net,” continuously monitoring and warning the user of possibly dangerous proximities, much like a ground-based ADS-B conflict detection system or a simplified ATC conflict advisory.

### Anomaly Detection
This consists of two subcomponents – a heuristic rule-based detector running in the browser, and an optional ML-based detector running on the server. The browser module quickly checks each new aircraft update for impossible or suspicious values (e.g., implausibly high speed or sudden position jumps). The server ML module takes a feature vector for each aircraft (encapsulating its behavior) and returns an anomaly score or label. The architecture keeps the ML part separate to leverage Python’s data science libraries and to allow more complex models without burdening the browser. 

In addition to collision risks, the system monitors incoming data for anomalies that could indicate errors or spoofing. Heuristic anomaly detection is built in as a first line of defense: each aircraft’s data is checked against a set of sanity rules. For example, if an aircraft reports a vertical climb/descent rate above a plausible threshold (e.g.,> $\pm$ 6000 feet per minute), it is flagged for an “excessive vertical rate” anomaly. Similarly, the system knows typical speed ranges for different aircraft categories (light propeller aircraft vs. jets vs. military fighters); if a reported ground speed is outside the realistic range for that type, it raises an alert for “invalid speed for type”. Another heuristic is detecting sudden jumps or teleportation: if the position of an aircraft changes more than a few nautical miles between consecutive updates (far more than it could physically travel), the system considers it a potential data spoof or glitch (“position jump” detected). Likewise, an abrupt course change (e.g., >90° heading change instantaneously) triggers an alert for improbable maneuver. 

These checks are implemented by storing the previous state of each aircraft (previous latitude, longitude, and track) and comparing with the new state on each update cycle, accumulating any issues found. If any rule is violated, the aircraft is marked as suspect: its 3D model icon on the map is tinted red and a warning symbol is added next to its label. All such events can also be logged to the console for debugging and record-keeping.

### Real-time Aircraft Tracking
In live operation, this module would interface with an ADS-B feed. This would be a network stream from a local ADS-B receiver (e.g., a Raspberry Pi running dump1090) or a public API from services like OpenSky Network. In the current setup, for demonstration, this module is simulated by generating test aircraft data with the actual data format. On startup, the system spawns a set of synthetic aircraft with randomized positions, altitudes, velocities, and types. This provides a realistic traffic load for testing without requiring actual radio input. The system continuously tracks aircraft positions and kinematics in real time. In live mode, it would parse incoming ADS-B messages (typically containing latitude, longitude, altitude, heading, and speed) and update the internal state for each aircraft. Every few seconds, an update loop recomputes each aircraft’s position based on its velocity (ground speed and track angle) and vertical rate, effectively propagating the aircraft along its current trajectory until new data arrives. Altitude is updated by integrating the vertical speed over the period. 

In addition, each aircraft’s last update timestamp is stored to ensure movement is time-accurate even if update intervals vary. The result is a live, moving picture of all aircraft, each following its projected path smoothly on the map. The tracking also handles adding new aircraft (as they appear in the data stream) and removing or ghosting aircraft that haven’t been seen for a while. Users can filter the view by aircraft type; for example, one can choose to display only commercial jets or only helicopters by selecting categories, and the system will hide other types. This is facilitated by an aircraft classification lookup (mapping specific aircraft ICAO types to categories like “Large Jet” or “Rotary Wing”) and a filter set that the user controls.

## Challenges

### Performance and Scalability
One of the biggest challenges was ensuring the system could handle many aircraft and frequent updates without lag, especially given the heavy computations for collision checking and the rendering of 3D models. A naive approach to collision detection would compare every pair of $N$ aircraft, leading to $O(N^2)$ checks, which becomes infeasible as the number of aircraft grows. To address this, we implemented spatial hashing to cut down the comparisons dramatically. By grouping aircraft into horizontal cells, the algorithm only checks pairs within the same cell, reducing complexity to roughly linear scaling for reasonably uniform distribution. 

In testing, this allowed the system to scale to tracking hundreds of aircraft in a region in real time, whereas the brute-force approach started choking much sooner. Another performance measure was using Cesium’s entity API to only update the needed properties each tick (position and orientation) and avoid re-creating entities unnecessarily. All dynamic visualization objects (aircraft models, labels, conflict lines) are either persistent or recycled each cycle to avoid thrashing the rendering engine. 
We also considered using web workers for offloading computations, but found it unnecessary after optimizations – the 2-second interval provided enough time for aircraft handling. If the workload increases in the future, we would consider more advanced spatial indexing (like a quadtree or KD-tree) or moving calculations to a background thread. But for our target use cases, the current approach meets real-time needs. Finally, we allow the user to adjust the update interval or horizon if they want a more aggressive or relaxed monitoring.

### ADS-B Data Integrity
ADS-B’s openness is a double-edged sword – while it provides data for free, it is unauthenticated, making it vulnerable to bad data or deliberate spoofing. The challenge was to build confidence in the system’s alerts by filtering out or flagging bogus data that could otherwise trigger false collision warnings or clutter the display. We implemented a multi-layer anomaly detection as described above. The heuristic rules were particularly effective at catching obvious errors: for instance, aircraft periodically reporting a ridiculous altitude jump will be marked by vertical rate checks, preventing any confusion with real threats. Another example was filtering speed: a Cessna broadcasting a speed of 600 knots is wrong. Without this filtering, it could erroneously be predicted to conflict with far-away jets due to its high speed.

During validation, we deliberately injected some spoof scenarios (like extremely fast-moving ghost aircraft) to see if the system responds. The separation of flagging also makes it clear whether an alert was due to heuristic rules or the model’s prediction, which can help in assessing trust. Lastly, the open-source nature of the project means others can further refine these detectors – update the speed thresholds, or retrain the isolation forest on more data, which addresses the evolving challenge of data integrity.

## Future Works

### ML model prediction
On the ML side, we faced the challenge of obtaining a good model without labeled anomaly data. The Isolation Forest was chosen because it doesn’t require labeled training examples. Tuning the contamination parameter (which controls the expected fraction of outliers) was tricky – too low and the model would miss obvious anomalies, too high and it would flag too many normal points. We settled on a small percentage (on the order of a few percent) of data to be flagged, based on domain intuition that anomalies are rare. It is important to know that this is not permanent, as the model can be refined to be replaced with more advanced models over time.

One idea is to use a neural network (such as an autoencoder or a recurrent network) that learns normal flight patterns over time and detects novel patterns. This could potentially capture complex anomalies that a simple isolation forest might miss. We also aim to incorporate feedback into the anomaly model – e.g., if the user flags an alert as false or true, that feedback could be used to supervise the model in the future. Moreover, extending the feature set to include temporal aspects (like variability of speed or acceleration) or comparing against known flight plan data could increase accuracy. All these would require a more sophisticated backend and dataset, which is an area for collaboration with the community or research partners.

### Data Recording and Replay
Adding a feature to record traffic data and replay it later would be beneficial for analysis and demonstration. This would involve logging all aircraft states and events to a file or database, and then having a “replay mode” where the simulation uses that recorded data instead of live input. This could help in debriefing after a training session or analyzing an incident (much like a flight data recorder for the airspace).

### Collision Avoidance Guidance
While the current system warns of potential collisions, a future feature could provide resolution advisories similar to TCAS. Using the known trajectories, the system could suggest an avoidance maneuver (e.g., “Aircraft A: climb 500 ft” or “turn 30° right”) to avert the collision, computed based on minimal disruption. This would involve more complex predictive algorithms and possibly an optimization routine to find a safe escape vector. Implementing this could greatly increase the utility of the system for pilot training or UAV traffic management, essentially making it not just an alert system but a decision-support tool.

Summing up, each of these enhancements will further improve the system’s capability, accuracy, or user-friendliness. Being an open-source project, these ideas could be implemented in the future or taken up by passionate successors.

## Demo 
Google Cloud Link: https://drive.google.com/file/d/19Zf9IPc6YngwOXt1dL5ksdtO3P2WA8vK/view?usp=sharing
